C++ Arrays and pointer
c++ Arrays
    배열은 각 값에 대해 별도의 변수를 선언하는 대신 단일 변수에 여러 값을 저장하는 데 사용된다
    배열을 선언하려면 변수 유형을 정의하고 배열 이름과 대괄호를 지정하고 저장해야 하는 요소 수를 지정한다
    type arrayName[length]; 
        %length를 지정안해줘도 초기화에 따라서 자동 할당 된다
        %itCompany라는 배열 길이 구하기? sizeof(itCompany) / sizeof(itCompany[0])
    
    int grade[3] = { 85, 65, 90} 이라하면 grade[0],grade[1],grade[2]는 주소들 
    각 4바이트 3개로 총 12bite의 공간을 차지하는데 grade를 찍어서 나오는게 메모리 주소이다.
    0000009A88AFFB08 메모리에 할당된 주소라 다 다르게 나온다
    grade[0] 찍어서 85가 나오면 메모리 주소로 찾아가서 값을 가져오는거다
    주소를 볼라면 &grade[0]으로 찍어보면 된다

    &는 참조 연산자라고 한다

references -> 동적할당, 리턴이 필요한 함수에서 등 사용할라고
    기존변수에 대한 참조(메모리 참조)이며, & 연산자를 사용한다
        -> 메모리의 주소 
    string food = "Pizza";
    string& meal = food; 
        => food의 주소값을 meal에 준거다 => 주소 찍어보면 같은 값 나옴 (당연히 변수도)
        => 같은 주소를 사용하므로 하나만 변수를 변경해도 같이 변경된다
    string food = "Pizza";
    string meal = food;
        => 이렇게 할당하면 같은 값을 가져도 메모리 주소는 달라진다

memory address
    변수의 메모리 주소를 얻는데에도 사용할 수 있다
    메모리에 변수가 저장되는 위치이다
    변수를 생성하면 변수에 메모리 주소가 할당된다
    그리고 변수에 값을 할당하면 이 메모리 주소에 저장된다
    access하려면 & 연산자를 사용한 변수가 저장된 위치를 나타낸다
        %컴퓨터의 메모리 데이터를 조작할 수 있는 능력을 제공하기 때문에 참조와 포인터는 중요하다
            => 주소하나에 값넣고 그 주소만 참조해다 쓰면 데이터 적으로 훨씬 효율적
        이러한 것은 code를 줄이고 성능을 향상시킬 수 있다

pointer 포인터도 인티저(4바이트)값?
    변수가 선언되면 그 값을 저장하는데 필요한 메모리의 특정 위치(메모리 주소)가 할당된다
    일반적으로 C++ 프로그램은 변수가 저장되는 정확한 메모리 주소를 능동적으로 결정하지 않는다
    다행히도 그 작업은 프로그램이 실행되는 환경에 맡겨진다
        일반적으로 런타임 시 특정 메모리 위치를 결정하는 것은 운영체제이다
    그러나 프로그램이 런타임 중에 변수에 대한 특정 위치에 있는 데이터 셀에 access 하기 위해 변수의 주소를 얻어오는 것이 유용할 수 있다
    c++에서 포인터란 메모리의 주소 값을 저장하는 변수이며, 포인터 변수라고 부른다
    char형 변수가 문자를 저장하고, int형 변수가 정수를 저장하는 것처럼 포인터는 주소 값을 저장하는데 사용된다

address of operator &(참조)
    변수의 주소는 변수 이름 앞에 주소 연산자라고 하는 &(ampersand)기호를 붙여서 얻을 수 있다
dereference oprerator * (이게 포인터용?)
    다른 변수의 주소를 저장하는 변수를 포인터라고 한다
    포인터는 주소가 저장되어 있는 변수를 가리키는 것이다

    string food = "Pizza";
    string* ptr = &food; 
        ptr 포인터에 food 주소값 저장? 포인터도 타입 일치시켜야한다
        *ptr 찍으면 주소를 찾아가서 값을 찍어준다
    포인터를 참조할때는 (2중 포인터)
    string** pptr = &ptr; ptr의 주소를 pptr에 넣어주므로 ptr pptr food 모두 같은 주소를 가진다 (2차원 배열을 사용할때 주로 사용)

C++ Modifiy Pointers
    포인터의 값을 변경할 수 있다
    그러나 이렇게 하면 원래 변수의 값도 변경된다 (같은 메모리 주소를 쓰니까) => 단 주소값은 당연히 변화없다

c++ pointer and Arrays
    배열의 개념은 포인터의 개념과 관련이 있다
        실제로 배열의 첫 번째 요소는 포인터와 매우 유사하게 작동하며 실제로 배열은 항상 적절한 유형의 포인터로 묵시적으로 변환될 수 있다
    포인터와 배열은 동일한 작업 집합을 지원하며 둘 다 동일한 의미를 갖는다
        주요 차이점은 포인터에는 새 주소를 할당할 수 있지만 배열에는 할당할 수 없다는 것이다

%int* ptr이 int *ptr보다 더 맞는 개념이라 int* ptr로 적는다

    배열에 대한 장에서 대괄호[] 는 배열의 요소의 인덱스를 지정하는 것이다 
        사실 이 괄호는 오프셋 연산자로 알려진 역참조 연산자이다
        그들은 뒤따르는 변수를 *처럼 역참조하지만 역참조되는 주소에 대괄호 사이의 숫자도 추가한다
    이 두표현식은 포인터인 경우 뿐 아니라 배열인 경우에도 동일하고 유효하다
        배열인 경우 해당 이름을 첫번째 요소에 대하여 포인터처럼 사용할 수 있음을 기억해야한다

pointer initialization
    포인터를 선언한 후 참조 연산자*를 사용하기 전에 포인터는 반드시 초기화되어야 한다
    초기화하지 않은 채로 참조 연산자를 사용하게 되면, 어딘지 알 수 없는 메모리 장소에 값을 저장하는 것이 된다

c++ pointer arithmetics(포인터 연산)
    포인터에서 산술 연산을 수행하는 것은 일반 정수 유형에서 수행하는 것은 다르다
    우선 덧셈과 뺄셈 연산만 허용되며 나머지 연산은 포인터의 세계에서 의미가 없다
    그러나 덧셈과 뺄셈은 포인터가 가리키는 데이터 유형의 크기에 따라 포인터에 대해 다른 동작을 한다
    기본 데이터 유형은 크기가 서로 다른 것을 배웠다
        예를 들어서 char의 크기는 항상 1바이트이고 short는 일반적으로 그보다 크며 int와 long은 훨씬 더 크다
        이들의 정확한 크기는 시스템에 따라 다르다
        예를 들어, 사용하는 시스템에서 char은 1바이트, short는 2바이트, long은 4를 사용한다고 가정해 보겠다
            char* mychar; ++char; 1바이트 이동
            short* myshort; ++myshort; 2바이트 이동
            long* mylong; ++mylong; 4바이트 이동

c++ pointer and string literals
    문자열 literal은 null로 끝나는 문자 sequence를 포함하는 배열이다(무조건 null로 끝난다)
    문자열 literal은 cout에 직접 사용되어 문자열을 초기화하고 문자 배열을 초기화하는데 사용되었다
        const char* foo = "hello"
    hello에 대한 literal 표현으로 배열을 선언하고 첫 번째 요소에 대한 포인터가 foo에 할당된다
        hello
    여기서 foo는 포인터이고 주소값 1702를 포함하고 h나 hello가 아니라 실제로 1702가 이 두가지의 주소이다
    포인터 foo는 일련의 문자를 가리킨다
        그리고 포인터와 배열은 표현식에서 본질적으로 같은 방식으로 동작하기 때문에 foo는 null로 끝나는 
        문자 sequence의 배열과 같은 방식으로 문자에 액세스하는 데 사용할 수 있다