class Methods
    메서드는 class에 속하는 member function이다
    클래스에 속하는 함수를 정의하는 두가지 방법이 있다
        inside class definition
        outside class definition
            클래스 정의 외부에서 함수를 정의하려면 클래스 내부에서 선언한 다음에

    속성에 액세스하는 것처럼 메서드에 액세스한다 
        클래스의 객체를 만들고 점 구문을 사용한다
    
% 보통 hpp로 만들때는 구현부까지 만들어주고 h파일로 만들때는 구현부는 cpp파일에 있다    

class methods parameter

c++ class constructors(default constructor)
    c++의 객체 생성자는 클래스의 객체가 생성될 때 멤버 변수를 초기화하며 자동으로 호출되는 특수 method이다
    생성자를 생성하려면 클래스와 동일한 이름을 사용하고 그 뒤에 괄호() 를 사용한다
        default constructor라고 한다
    생성자는 클래스와 이름이 같으며 항상 public이며 return값이 없다
    %객체가 생성될때 가장 초기화 해줄때 주로 사용 -> 그래서 default

C++ class Constructor Parameters
    생성자는 속성의 초기값을 설정하는데 유용할 수 있는 매개변수(일반 함수와 마찬가지로)를 사용할 수 있다
    함수와 마찬가지로

C++ the class destructor (파괴자 or 소멸자)
    소멸자는 클래스의 객체가 범위를 벗어날 때마다 또는 삭제식 즉 삭제시 해당 클래스의 객체에 대한 포인터에 대하여 
        적용될때마다 실행되는 클래스의 특수 멤버 함수이다
    한마디로 객체가 메모리에 반납될때 실행되는 함수이다
    소멸자는 접두사(~)가 붙는 클래스와 정확히 같은 이름을 가지며 값을 반환하거나 매개변수를 사용할 수 없다
        소멸자는 파일닫기 메모리 해제등과 같이 프로그램에서 나오기 전에 리소스를 해제하는데 매우 유용할 수 있다

%m_ 라고 시작하는 이유는 member 표시 
    소멸자의 호출
        C++에서 소멸자의 호출 시기는 컴파일러가 알아서 처리하게 된다
        C++에서 객체가 선언된 메모리 영역별로 소멸자가 호출되는 시기는 다음과 같다
            데이터영역 : 해당 프로그램이 종료될 때
            스택 영역 : 해당 객체가 정의된 블록을 벗어날 때
            힙 영역 :

copy constructor(복사생성자)
    얕은 복사와 깊은 복사
        deep copy
            새롭게 생성하는 변수에 다른 변수의 값을 대입하기 위해서 대입 연산자를 사용하면 된다
        shallow copy
            새롭게 생성하는 객체에 또 다른 객체의 값을 대입하기 위해서도 대입 연산자를 사용할 수 있다
            하지만 대입 연산자를 이용한 객체의 대입은 얕은 복사로 수행된다
            얕은 복사란 값을 복사하는 것이 아닌, 값을 가리키는 포인터를 복사하는 것이다
            따라서 변수의 생성에서 대입 연산자를 이용한 값의 복사는 문제가 되지 않지만,
                객체에서는 문제가 발생할 수도 있다
            특히 객체의 멤버가 메모리 공간의 힙 영역을 참조할 경우에는 문제가 발생한다

    C++에서 복사 생성자란 자신과 같은 클래스 타입의 다른 객체에 대한 참조를 인수로 전달받아 
        그 참조를 가지고 자신을 초기화하는 방법이다
    복사 생성자는 새롭게 생성되는 객체가 원본 객체와 같으면서도, 완전한 독립성을 가지게 해준다
    왜냐하면, 복사 생성자를 이용한 대입은 깊은 복사를 통한 값의 복사이기 때문이다
    복사 생성자는 다음과 같은 상황에서 주로 사용된다
        객체가 함수에 인수로 전달될 때
        함수가 객체를 반환 값을 반환할때
        새로운 객체를 같은 클래스 타입의 기존 객체와 똑같이 초기화할 때

    this 복사생성자
        해당 멤버함수를 호출한 object를 가리킨다??

C++ overloading
    c++에서는 함수 이름 또는 동일한 범위의 연산자에 대해 둘 이상의 정의를 지정할 수 있다
        이를 각각 함수 오버로딩 및 연산자 오버로딩이라고 한다
    오버로드 된 선언은 동일한 범위에서 이전에 선언된 선언과 동일한 이름으로 선언된 선언이다
        단, 두 선언 모두 인수가 다르고 정의가 분명히 다르다
    오버로드 된 함수 또는 연산자를 호출할때 컴파일러는 함수 또는 연산자를 호출하는데 사용한 인수 유형을
        정의에 지정된 매개변수 유형과 비교하여 사용할 가장 적절한 정의를 결정한다
        가장 적절한 오버로드 된 함수 또는 연산자를 선택하는 프로세스를 오버로드 해결(resolution)이라고 한다

C++ class function overloading
    동이란 범위에서 동일한 함수 이름에 대해 여러 정의를 가질 수 있다
    함수의 정의는 인수 목록의 인수 유형 또는 이 수의 (갯)수에 따라 서로 달라야 한다
    반환 유형만 다른 함수 선언은 오버로드 할 수 없다

Operators overloading in C++
    C++에서 사용할 수 있는 대부분의 기본 제공 연산자를 재정의하거나 오버로드 할 수 있다.
        따라서 프로그래머는 사용자 정의 유형과 함께 연산자도 사용할 수 있다
    오버로드 된 연산자는 특수 이름을 가진 함수이다
        keyword operator 다음에 정의되는 연산자의 기호가 온다
        다른 함수와 마찬가지로 오버로드 된 연산자에는 반환 형식과 매개 변수 목록이 있다
    operator 오버로딩 할 연산자(매개변수목록)

%private에 선언한 변수는 외부에서 접근할 수 없다?

Define Operators function in C++
    C++에서 연산자 함수를 정의하는 방법은 다음과 같이 두 가지 방법이 있다
        클래스의 멤버 함수로 정의하는 방법
        전역 함수로 정의하는 방법
    이 두 방법의 차이는 인수의 개수 뿐만 아니라 private에

오버로딩의 제약 사항
    C++에서 연산자를 오버로딩 할 때에는 다음과 같은 사항을 지켜야 한다
        전혀 새로운 연산자를 정의할 수는 없다
        기본 타입을 다루는 연산자의 의미는 재정의할 수 없으며, 따라서 오버로딩 된 연산자의 피연산자 중 하나는 반드시 사용자 정의 타입이어야 한다
        오버로딩된 연산자는 기본 타입을 다루는 경우에 적용되는 피연산자의 수, 우선순위 및 그룹화를 준수해야 한다
        오버로딩 된 연산자는 디폴트 인수를 사용할 수 없다

    오버로딩 불가능 연산자

    멤버 함수로만 오버로딩 할 수 있는 연산자