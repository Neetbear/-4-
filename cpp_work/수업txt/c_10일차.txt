Data hiding(정보 은닉)
    C++에서 구조체의 모든 멤버는 외부에서 언제나 접근할 수 있다
    하지만 클래스는 객체 지향 프로그래밍의 기본규칙 중 하나인 정보 은닉에 대해서도 생각해야만 한다
    정보 은닉이란 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다는 개념이다
    그렇게 함으로써 사용자는 언제나 최소한의 정보만으로 프로그램을 손쉽게 사용할 수 있게 된다

C++ class access specifiers
    C++에서는 이러한 정보 은닉을 위해 접근 제어라는 기능을 제공하고 있다
    접근 제어란 접근 제어 지시자를 사용해 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정할 수 있도록 하여,
        정보 은닉을 구체화하는 것을 의미한다
    C++  에서는 다음과 같은 세가지 접근 제어 지시자를 제공한다
        public
            public 접근 제어 지시자를 사용하여 선언된 클래스 멤버는 외부로 공개되며, 
                해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있다
            따라서 public 멤버 함수는 해당 객체의 private 멤버와 프로그램 사이의 인터페이스 역할을 하게 된다
            프로그램은 이러한 public멤버 함수를 통해 해당 객체의 private멤버에도 접근할 수 있도록 구현해야한다
        private
            private 접근 제어 지시자를 사용하면 선언된 클래스 멤버는 외부에 공개되지 않으며, 
                외부에서 직접 접근할 수도 없다
            프로그램은 private 멤버에 직접 접근할 수 없으며, 
                해당 객체의 public 멤버 함수를 통해서만 접근할 수 있다
            클래스의 기본 접근 제어 권한은 private로 설정되어 있으므로, 
                클래스 선언시 private접근 제어 지시자는 생략할 수 있다
            일반적으로 private 멤버는 public 인터페이스를 직접 구성하지 않는
        protected
            C++ 클래스는 private 멤버로 정보를 은닉하고,
                public 멤버로 사용자나 프로그램과의 인터페이서를 구축한다
            여기에 파생 클래스(derived class)와 관련된 접근 제어 지시자가 하나 더 존재한다
            protected 멤버는 파생 클래스에 대해서는 public멤버처럼 취급되며, 
                외부에서는 private 멤버처럼 취급된다
            protected 멤버에 접근할 수 있는 영역은 다음과 같다
                이 멤버를 선언한 클래스의 멤버 함수
                이 멤버를 선언한 클래스의 friend class
                이 멤버를 선언한 클래스에서 public 또는 protected 접근 제어로 파생된 클래스(상속된 클래스)
    클래스의 기본 접근 

%클래스의 접근 제어 지시자의 default는 private이다 
%friend class는 object oriented programming개념에 반하므로 자주 사용하지는 않는다

C++ Encapsulation
    모든 C++ 프로그램은 다음 두 가지 기본 요소로 구성된다
        프로그램 명령문(코드) - 이것은 작업을 수행하는 프로그램의 일부이며 이를 함수라고 한다
        프로그램 데이터 - 데이터는 프로그램 기능의 영향을 받는 프로그램의 정보이다
    캡슐화는 데이터와 데이터를 조작하는 기능을 함께 묶고 외부 간섭과 오용으로부터 안전하게 유지하는
        객체 지향 프로그래밍 개념이다
    데이터 캡슐화는 데이터 은닉의 중요한 OOP 개념으로 이어졌다
    데이터 캡슐화는 데이터를 묶는 mechanism이며, 이를 사용하는 함수와 데이터 추상화는 인터페이스만 
        노출하고 구현 세부 사항을 사용자에게 숨기는 mechanism이다
    캡슐화의 의미는 민감한 데이터가 사용자에게 숨겨져 있는지 확인하는 것이다 
        이를 달성하려면 클래스 변수/속성을 private로 선언해야 한다
        (클래스 외부에서 액세스할 수 없음)
    다른 사람들이 private 멤버의 값을 읽거나 수정하도록 하려면 public get 및 set 메서드를 제공해야 한다

Why Encapsulation?
    클래스 속성을 비공개로 선언하는 것은 좋은 습관이다
        캡슐화는 다른 부분에 영향을 주지 않고 코드의 한 부분을 변경할 수 있으므로 데이터를 더 잘 제어할 수 있따
    데이터 보안이 향상된다

Designing Strategy(디자인 전략)
    우리 대부분은 클래스 멤버를 실제로 노출해야 하는 경우가 아니면 기본적으로

C++ inheritance
    객체 지향 프로그래밍에서 가장 중요한 개념 중 하나는 상속 개념이다
    상속을 통해 다른 클래스의 관점에서 클래스를 정의할 수 있으므로 Application을 더 쉽게 만들고 유지관리 할수 있다
    이것은 또한 코드 기능을 재사용할 수 있는 기회를 제공하고 빠른 구현 시간의 기회를 제공한다
    클래스를 생성할 때 완전히 새로운 데이터 멤버와 멤버 함수를 작성하는 대신 프로그래머는 새 클래스가 기존 클래스의 멤버를 상속하도록 지정할 수 있다
        이 기존 클래스를 기본 클래스라고 하고 새 클래스를 파생 클래스라고 한다
    상속을 구현한다는 관계의 아이디어이다
        예를 들어 포유류 Is-A 동물, 개 Is-A 포유류, 따라서 개 Is-A 동물 등이다
    C++ 에서는 상속 개념은 두가지 범주의 그룹이 있다
        derived class (파생 클래스 / 자식) 다른 클래스에서 상속받은 클래스
        base class(기본 클래스 / 부모) 상속이 되는 클래스

Why And When to use inheritance
    attributes와 methods 재사용할때 ?

Access control and inheritance
    파생 클래스는 기본 클래스의 모든 비공개 멤버에 액세스할 수 있다
    따라서 파생 클래스의 멤버 함수에 액세스할 수 없는 기본 클래스 멤버는 기본 클래스에서 private로 선언되어야한다
    다음과 같은 방식으로 액세스 할 수 있는 사용자에 따라 다양한 액세스 유형을 요약할 수 있다
    파생 클래스는 다음을 제외하고 모든 기본 클래스 메서드를 상속한다
        constructor, destructor and copy constructor of the base class
        overloaded operator of the base class
        the friend function of the base class

type of inheritance
    기본 클래스에서 클래스를 파생할 때 기본 클래스는 public, protected 또는 private 상속을 통해 상속될 수 있다

    다른 유형의 상속을 사용한느 동안 다음 규칙이 적용된다
        거의 public쓴다
        public inheritance
        protected inheritance
        private inheritance
    
%virtual int GetArea() = 0; 자식 클래스에 다 int GetArea()를 구현하라는 내용

Multilevel Inheritance(다단계 상속)
    클래스는 이미 다른 클래스에서 파생된 한 클래스에서 파생도리 수도 있다

Multiple Inheritance(다중상속)
    클래스는 쉼표(,)로 구분된 목록을 사용하여 둘 이상의 base class에서 파생될 수도 있다
    이것을 다중 상속이라 한다

C++ class friend
    C++에서 객체의 private 멤버에는 해당 객체의 public 멤버 함수를 통해서만 접근할 수 있다고 했다
    하지만 경우에 따라서는 해당 객체의 멤버 함수가 아닌 함수도 private 멤버에 접근해야만 할 경우가 발생한다
    이럴때마다 매번 private 멤버에 접근하기 위한 새로운 public 멤버 함수를 작성하는 것은 매우 비효율적이다
    따라서 C++ 

C++ definition of friend function

C++ class static member variables
    C++에서 static member란 클래스에는 속하지만, 객체 별로 할당되지 않고 클래스의 모든 객체가 공유하는 멤버를 의미한다
    멤버 변수가 정적으로 선언되면, 해당 클래스의 모든 객체에 대해 하나의 데이터만이 유지 관리된다
    정적 멤버 변수는 클래스 영역에서 선언되지만, 정의는 파일 영역에서 수행된다
    이러한 정적 멤버 변수는 외부 연결을 가지므로, 여러 파일에서 접근할 수 있다
    정적 멤버 변수에도 클래스 멤버의 접근 제한 규칙이 적용되므로, 클래스의 멤버 함수나 friend만이 접근할 수 있다
    하지만 정적 멤버 변수를 외부에서도 접근할 수 있게 하고 싶으면, 정적 멤버 변수를 public 영역에 선언하면 된다

C++ polymorphism

virtual function
    가상 함수는 virtual 키워드를 사용하여 선언된 기본 클래스의 함수이다
        파생 클래스의 다른 버전과 함께 기본 클래스에서 가상 함수를 정의하면 이 함수에 대한 정적 연결을 원하지 않는다는 신호가 컴파일러에 전달된다
    우리가 원하는 것은 호출되는 객체의 종류를 기반으로 프로그램의 주어진 지점에서 호출될 함수를 선택하는 것이다
        이러한 종류의 작업을 동적 연결 또는 후기 바인딩이라고 한다

pure virtual function
    기본 클래스에 가상 함수를 포함하여 해당 클래스의 객체에 맞게 파생 클래스에서 재정의할 수 있지만 기본 클래스의 함수에 대해 의미 있는 정의를 제공할 수 없다
    기본 클래스의 가상 함수를 다음과 같이 변경할 수 있다
    = 0 는 함수에 본문과 
%반드시 구현부문이 있어야 한다?

polymorphism - abstract class (추상)
    c++ 에서는 하나 이상의 순수 가상 함수를 포함하는 클래스를 추상 클래스라고 한다
    이러한 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가진 함수의 집합을 정의할 수 있게 해준다
    즉, 반드시 사용되어야 하는 멤버 함수를 추상 클래스에 순수 가상함수로 선언해 놓으면, 
        이 클래스로부터 파생된 모든 클래스에서 는 이 가상 함수를 반드시 재정의해야 한다
    추상 클래스는 동작이 정의되지 않은 순수 가상 함수를 포함하고 있으므로, 인스턴스를 생성할 수 없다
    따라서 추상 클래스는 먼저 상속을 통해 파생 클래스를 만들고, 
        만든 파생 클래스에서 순수 가상 함수를 모두 overriding 하고 나서야 비로소 파생 클래스의 인스턴스를 생성할 수 있게 된다
    하지만 추상 클래스 타입의 포인터와 참조는 바로 사용할 수 있다

    추상 클래스의 용도 제한 
        변수 또는 멤버 변수
        함수에 전달되는 인수 타입
        함수의 반환 타입
        명시적 타입 변환의 타입

overriding
    상속 overriding을 보자, 전에 배웠던 함수 overloading이 생각난다
    overloading이 매개변수의 자료형이나 수가 다른 함수를 같은 이름으로 여러 번 중복 정의하는 것이라면
        overriding은 이미 있는 함수를 무시하고 새롭게 함수를 재정의하는 것이다
        더 자세히 말하자면, 이 오버라이딩(재정의)은 부모 클래스와 자식 클래스의 상속 관계에서 부모 클래스에 
        이미 정의된 함수를 같은 이름으로 자식 클래스에서 재정의 하는 것이다
    이때, 부모의 멤버 함수와 원형이 완전히 같아야 한다
        그리고 오버라이딩시 부모 클래스의 함수가 모두 가려진다

Data abstraction in C++(data 추상화)
    데이터 추상화는 외부 세계에 필수적인 정보만 제공하고 배경 세부 정보를 숨기는 것,
        즉 세부 정보를 제시하지 않고 프로그램에서 필요한 정보를 표현하는 것을 말한다
    데이터 추상화는 인터페이스와 구현의 분리에 의존하는 프로그래밍 및 디자인 기술이다
    C++에서 클래스는 뛰어난 수준의 데이터 추상화를 제공한다
    객체의 기능을 사용하고 객체 데이터, 즉 클래스가 내부적으로 구현된 방법을 실제로 알지 못하는 상태를 조작할 수 있도록
        외부세계에 충분한 public method를 제공한다
    C++에서는 클래스를 사용하여 고유한 ADT(abstract data type)를 정의한다
    액세스 레이블은 추상화를 시행한다
    C++ 에서는 엑세스 레이블을 사용하여 클래스에 대한 abstract interface를 정의한다
    클래스는 0개 또는 그 이상의 액세스 레이블을 포함할 수 있다
        public laber로 정의된 멤버는 프로그램의 모든 부분에 액세스할 수 있다
        형식의 데이터 추상화 보기는 해당 public member

interfaces in C++ (abstract classes)
    interface는 해당 클래스의 특정 구현을 커밋하지 않고 C++ 클래스의 동작 또는 기능을 설명한다
    C++ interface는 추상 클래스를 사용하여 구현되며 이러한 추상 클래스는 구현 세부 정보를 관련 데이터와 별도로 
        유지하는 
    

    Abstract Class (ABC/추상클래스)의 목적은 다른 클래스가 상속할 수 있는 적절한 기본 클래스를 제공하는 것이다
    추상 클래스는 객체를 인스턴스화하는데 사용할 수 없으며 interface 역할만 한다
        추상클래스의 객체를 인스턴스화하려고 하면 컴파일 오류가 발생한다
    따라서 ABC의 하위 클래스를 인스턴스화해야 하는 경우 각 virtual function을 구현해야 하며,
        이는 ABC에서 선언한 인터페이스를 지원한다는 것을 의미한다
    
    부모 클래스가 getArea()라는 함수를 
