new[] delete[]
    new[] operator
        문자배열, 즉 20자의 문자열에 대한 메모리를 할당한다고 가정하면, 예제와 같이 메모리를 동적으로 할당할 수 있다
            char* pvalue = null;
            pvalue = new char[n]; 

    delete[] operator
        앞장에서 생성한 배열을 제거하려면 다음과 같이 한다
            delete [] pvalue;

C++ two dimensional Array
    2차원 배열이란 배열의 요소로 1차원 배열을 가지는 배열이다
    c++ 에서는 2차원 배열을 나타내는 타입을 따로 제공하지 않는다
    대신에 1차원 배열의 배열 요소로 또 다른 1차원 배열을 사용해서 2차원 배열을 나타낼 수 있다
    type은 배열 요소로 저장되는 변수의 타입을 설정한다
    arrName은 배열이 선언된 후에 배열에 접근하기 위해 사용된다
        type arrayName[x][y];
    
    하지만 컴퓨터의 memory는 입체적 공간이 아닌 선형 공간이므로 실제적으로는 다음 그림과 같이 저장된다
        int arr2[2][3] = {10,20,30,40,50,60}; // == { { 10, 20, 30 }, { 40, 50, 60 } } 

다중 배열 초기화
    { { 10, 20, 30 }, { 40, 50, 60 } } 
    다차원 배열은 각 행에 대괄호로 묶인 값을 지정하여 초기화 할수 있다
    
    {10,20,30,40,50,60};
    행을 나타내는 중첩 중괄호는 선택 사항이다
    다음 초기화는 이전 예제와 동일하다

c++ Pointers to pointer & Arrays
    [row][col] 크기의 2차원 배열
        원소를 col개 가지고 있는 1차원 배열이 row개 있는 것
        1차원 배열의 주소가 row개 있는 것이나 마찬가지이다
        2차원 배열은 포인터의 배열이나 마찬가지다

%% 스마트 포인터(unique_ptr / shared_ptr / weak_ptr)
    -unique_ptr은 하나의 스마트 포인터만이 특정 객체를 소유할 수 있도록, 객체에 소유권 개념을 도입한 포인터이다
    -shared_ptr은 하나의 특정 객체를 참조하는 스마트 포인터가 총 몇 개인지를 참조하는 스마트 포인터이다 (제일 많이 사용된단)
    -weak_ptr은 하나 이상의 shared_ptr 인스턴스가 소유하는 객체에 대한 접근을 제공하지만, 소유자의 수에는 포함되지 않는 스미트 포인터이다

C++ Function
    함수는 호출될 때만 실행되는 코드 블록이다
    매개변수라고 하는 데이터를 함수에 전달할 수 있다
    함수는 특정 작업을 수행하는데 사용되며 코드를 재사용하는데 중요하다
        코드를 한 번 정의하고 여러번 사용한다
    코드를 별도의 기능으로 나눌 수 있다
        코드를 다른 기능으로 나누는 방법은 사용자에게 달려 있지만 논리적으로 구분은 일반적으로 각 기능이 특정 작업을 수행하도록 한다

defining a Function
    C++는 코드를 실행하는데 사용되는 main과 같은 일부 미리 정의된 함수를 제공한다
        그러나 특정 작업을 수행하기 위해 고유한 기능을 만들수도 있다
    함수를 생성(종종 선언이라고도함)하려면 함수 이름을 지정하고 그 뒤에 괄호()를 붙인다

call a Function
    C++ 함수를 생성하는 동안 함수가 수행해야 하는 작업에 대한 정의를 제공한다
        함수를 사용하려면 해당 함수를 호출해야한다
        프로그램이 함수를 호출하면 프로그램 제어가 호출된 함수로 이전된다
    호출된 함수는 정의된 작업을 수행하고 return문이 실행되거나 함수 끝 닫는 중괄호에 도달하면 프로그램 제어를 
        다시 호출한 메인 프로그램 또는 호출한 함수로 반환한다

C++ Function Parameters
    정보는 매개변수로 함수에 전달할 수 있습니다
        매개변수는 함수 내에서 변수 역할을 한다
    매개변수는 함수 이름 뒤에 괄호 안에 지정된다
        원하는 만큼 매개변수를 추가할 수 있다
         쉼표(,)로 구분하기만 하면 된다

C++ Function Default Parameter Value
    등호를 사용하여 기본 매개변수 값을 사용할 수도 있다
    인수 없이 함수를 호출하면 기본값이 사용된다
C++ Function Multiple Parameters
    함수 내에서 원하는 만큼 매개변수를 추가할 수 있다    

C++ Function Return Value
    이전 예에서 사용된 void 키워드는 함수가 값을 반환하지 않아야 함을 나타낸다
    함수가 값을 반환하도록 하려면 void 대신 데이터 type(유형)(예: int, string 등)을 사용하고 함수 내에서 return 키워드를 사용한다
    이전 예제에서는 함수에 매개변수를 전달할 때 일반 변수를 사용했다
    함수에 대한 매개변수를 참조로 전달할 수 도 있다
        이는 인수 값을 변경해야 할 때 유용할 수 있다 

C++ Function Pass By Reference Argurment
    주소 참조로 받아와서 처리하면 return없어도 값이 변한다

C++ Function Overloading
    디폴트 인수가 인수의 개수를 달리하여 같은 함수를 호출하는 것이라면, 함수 오버로딩은 같은 이름의 함수를 중복하여 정의하는 것을 의미한다
    C++에서 새롭게 추가된 함수 오버로딩은 여러 함수를 하나의 이름으로 연결해 준다
    즉, 함수 오버로딩이란 같은 일을 처리하는 함수를 매개변수의 형식을 조금씩 달리하여, 하나의 이름으로 작성할 수 있게 해주는 것이다
    이와 같은 함수 오버로딩은 객체 지향 프로그래밍의 특징 중 바로 다형성(polymorphism)의 구현이다

C++ Function signature
    함수 오버로딩의 핵심은 바로 함수 시그니쳐에 있다
    함수 시그니처란 함수의 원형에 명시되는 매개변수 리스트를 가리킨다
    만약 두 함수가 매개변수의 개수와 그 타입이 모두 같다면, 이 두 함수의 시그니처는 같다고 할 수 있다
    즉, 함수의 오버로딩은 서로 다른 시그니처를 갖는 여러 함수를 같은 이름으로 정의하는 것이라고 할 수 있다

%call by pointer, value, reference 매개변수로 받는 유형에 따라 분류(int* number / int number / int& number)

C++ Function Pointer
    프로그램이 정의된 함수는 프로그램이 실행될 때 모두 메인 메모리에 올라간다
    이때 함수의 이름은 메모리에 올라간 함수의 시작 주소를 가리키는 포인터 상수가 된다
    이렇게 함수의 시작주소를 가리키는 포인터 상수를 함수 포인터라고 부른다
    함수의 포인터의 포인터 타입은 함수의 반환값과 매개변수에 의해 결정된다
    즉 함수의 원형을 알아야만 해당 함수에 맞는 함수 포인터를 만들 수 있다

    %포인터 상수란 포인터 변수가 가리키고 있는 주소 값을 변경할 수 없는 포인터를 의미하며
     상수 포인터란 상수를 가리키는 포인터를 의미한다

    함수의 원형 void Func(int, int);
    함수 포인터 void (*ptr_func)(int, int);