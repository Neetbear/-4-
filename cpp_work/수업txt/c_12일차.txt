Generic programming
    c++이 가지는 프로그래밍 언어로서의 특징 중 하나로 일반화 프로그르맹을 들 수 있다
    일반화 프로그래밍은 데이터를 중시하는 객체 지향 프로그래밍과는 달리 프로그램의 알고리즘에 그 중점을 둔다
    이러한 일반화 프로그램을 지원하는 C++의 대표적인 기능 중 하나가 바로 템플릿이다
Template
    템플릿이란 매개변수의 타입에 따라 함수나 클래스를 생성하는 메커니즘을 의미한다
    템플릿은 타입이 매개변수에 의해 표현되므로, 매개변수화 타입이라고도 불린다
    템플릿을 사용하면 타입마다 별도의 함수나 클래스를 만들지 않고, 
        여러 타입에서 동작할 수 있는 단 하나의 함수나 클래스를 작성하는 것이 가능하다
Function Template
    c++에서 함수 템플릿이란 함수의 일반화된 선언을 의미한다
    함수 템플릿을 사용하면 같은 알고리즘을 기반으로 하면서, 서로 다른 타입에서 동작하는 함수를 한 번에 정의할 수 있다
    임의의 타입으로 작성된 함수에 특정 타입을 매개변수로 전달하면, c++ 컴파일러는 해당 타입에 맞는 함수를 생성해 준다
    C++에서 함수 템플릿은 다음과 같은 문법으로 정의한다
        template <typename T> void Swap(T& a, T& b); 
    
함수 템플릿의 인스턴스화
    함수 템플릿이 각각의 타입에 대해 처음으로 호출될 때, C++ 컴파일러는 해당 타입의 인스턴스를 생성한다
    이렇게 생성된 인스턴스는 해당 타입에 대해 특수화된 템플릿 함수이다
    이 인스턴스는 함수 템플릿에 해당 타입이 사용될 때마다 호출된다

class template
    c++에서 클래스 템플릿이란 클래스의 일반화된 선언을 의미한다
    앞서 살펴본 함수 템플릿과 동작은 같으며, 그 대상이 함수가 아닌 클래스라는 점만 다르다
    클래스 템플릿을 사용하면, 타입에 따라 다르게 동작하는 클래스 집합을 만들 수 있다
    즉, 클래스 템플릿에 전달되는 템플릿 인수에 따라 별도의 클래스를 만들 수 있게 된다
    이러한 템플릿 인수는 타입이거나 명시된 타입의 상수값일 수 있다
    C++에서 클래스 템플릿은 다음과 같은 문법으로 정의할 수 있다
        template <class type> class class-name{...}

nested class template (중첩 클래스 템플릿) -> 쓸수는 있으나 권장하는 방법은 아님
    C++에서는 클래스나 클래스 템플릿 내에 또 다른 템플릿을 중첩하여 정의할 수 있으며,
        이러한 템플릿을 멤버 템플릿이라고 한다 
        멤버 템플릿 중에서도 클래스 템플릿 

C++ STL(Standard template library)  -> vector 등등? 
    c++이 가지는 프로그래밍 언어로서의 특징 중 하나로 일반화 프로그래밍을 들 수 있다
    이러한 일반화 프로그래밍은 데이터를 중시하는 객체 지향 프로그래밍과는 달리 프로그램의 알고리즘에 그 중접을 둔다
    C++ 표준 템플릿 라이브러리인 STL도 이러한 일반화 프로그래밍 패러다임의 한 축을 담당하고 있다
    STL은 알고리즘을 일반화한 표현을 제공하여, 데이터의 추상화와 코드를 재활용할 수 있게 한다
    STL은 1994년 휴렛팩커드연구소의 알렉스 스테파노프와 멩리가 처음으로 그 구현을 발표했다
    그 후 STL은 ISO/ANSI C++ 표준 위원회에 의해 C++ 표준 템플릿 라이브러리로 포함되게 된다

STL components
    컨테이너(container)
        컨테이너는 특정 종류의 객체 컬렉션을 관리하는데 사용된다
        deque, list, vector, map 등과 같은 여러 유형의 컨테이너가 있다
    반복자(iterator)
        반복자는 객체 컬렉션의 구송요소를 단계별로 실행하는데 사용된다
        이러한컬렉션은 컨테이너 또는 컨테이너의 하위 집합일 수 있다
    알고리즘(Algorithm)
        알고리즘은 컨테이너에서 작동한다
        반복자를 이용해서 컨테이너 내용의 초기화, 정렬, 검색 및 변환을 수행하는 수단을 제공한다?

컨테이너
    STL에서 컨테이너는 같은 타입의 여러 객체를 저장하는 일종의 집합이라 할 수 있다
    컨테이너는 클래스 템플릿으로, 컨테이너 변수를 선언할 때 컨테이너에 포함할 요소의 타입을 명시할 수 있다
    STL에서 컨테이너는 크게 두가지 종류가 있다
        먼저 배열처럼 객체들을 순차적으로 보관하는 스퀀스 컨테이너(sequence container)와 
        키를 바탕으로 대응되는 값을 찾아주는 연관 컨테이너(associative container)가 있다

스퀀스 컨테이너
    시퀀스 컨테이너에는 vector, list, deque 이렇게 3개가 정의되어 있다. 
        먼저 백터의 경우 쉽게 생각하면 가변길이 배열이라 생각하면 된다
        벡터에는 원소들이 메모리 상에서 실제로 순차적으로 저장되어 있고, 따라서 임의의 위치에 있는 원소를 접근하는 것을 매우 빠르게 수행할 수 있다
        벡터의 임의의 원소에 접근하는 것은 배열처럼 []를 이용하거나, at함수를 이용하면 된다.
        또한 맨뒤에 원소를 추가하거나 제거하기 위해서는 push_back 혹은 pop_back 함수를 사용하면 된다
        벡터의 크기를 return하는 함수인 size의 경우, return하는 값의 타입은 size_type 멤버 타입으로 정의되어 있다

        %백터에서는 원소를 중간에서 하나 빼면 자리바꿈을 다 해주므로 중간을 건드리면 느리다

반복자
    반복자는 컨테이너의 원소에 접근할 수 있는 포인터와 같은 객체라 할 수 있다
        물론 벡터의 경우 []를 이용해서 정수형 변수로 마치 배열처럼 임의의 위치에 접근할 수 있지만,
        반복자를 사용해서도 마찬가지 작업을 수행할 수 있다
        특히 알고리즘 라이브러리의 경우 대부분이 반복자를 인자로 받아서 알고리즘을 수행한다
    반복자는 컨테이너에 반복자 멤버 타입으로 정의되어 있다
        벡터의 경우 반복자를 얻기 위해서는 begin() 함수와 end() 함수를 사용할 수 있는데 이는 다음과 같은 위치를 반환한다
    begin함수는 예상했던 대로, 벡터의 첫번째 원소를 가리키는 반복자를 반환한다
        그런데 흥미롭게도 end의 경우 벡터의 마지막 원소 한 칸 뒤를 가리키는 반복자를 반환하게 된다
        
    벡터에서 반복자로 erase나 insert할때 주의할 점이 있다
        컨테이너에 원소를 추가하거나 제거하게 되면 기존에 사용하였던 모든 반복자들을 사용할수 없게 된다
        다시 말해 위경우 vec.erase(itr)을 수행할 수 없게 된다?

    vector에서 지원하는 반복자로는 const_iterator가 있다
        이는 마치 const pointer를 생각하면 된다

    const 반복자가 가리키고 있는 값은 바꿀수 없다고 오류가 발생한다
        주의할 점은, const 반복자의 경우 cbegin()과 cend() 함수를 이용하여 얻을 수 있다
    많은 경우 반복자의 값을 바꾸지 않고 참조만 하므로 const iterator를 사용하는 것이 좋다

    역반복자

list 양방향연결구조 자료형(double linked)
    vector와는 달리 임의의 위치에 있는 원소에 접근을 바로 할 수 없다
    list 컨테이너 자체에서는 시작 원소와 마지막 원소의 위치만을 기억하기 때문에, 
        임의의 위치에 있는 원소에 접근하기 위해서는 하나씩 링크를 따라가야 한다
    그래서 리스트에는 아예 []나 at 함수가 정의되어 있지 않다
    리스트의 반복자의 경우 다음과 같은 연산자 밖에 수행할 수 없다
        ++ or --
        itr* 5 같은 연산은 불가능하다
            즉 임의의 위치에 있는 원소를 가리킬 수 없다
            반복자는 오직 하나씩 밖에 움직일 수 없다
        이와 같은 이유는 list의 구조를 생각해보면 알 수 있다
            앞서 말했듯이 리스트는 왼족혹은 오른쪽을 가리키고 있는 원소들의 모임으로 이루어져 있기 때문에, 한번에 한칸식 밖에 이동할 수 없다
            즉, 메모리 상에서 원소들이 
    
deque(double ended queue) queue는 일방통행 deque는 양방향
    deque는 백터와 비슷하게 임의의 위치의 원소에 접근할 수 있으며 맨 뒤에 원소를 추가/제거 하는 작업도 수행할 수 있다
        또한 벡터와는 다르게 맨 앞에 원소를 추가/제거 하는 작업까지도 수행 가능하다
    벡터와는 다르게 deque의 경우 원소들이 실제로 메모리 상에서 연속적으로 존재하지는 않는다
        이 때문에 원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리를 더 필요로 한다
    실제 예로 64비트

