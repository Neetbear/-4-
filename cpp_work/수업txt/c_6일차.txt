C++ Pointer to Pointer (이중 포인터)
    c++에서는 포인터를 가리키는 포인터를 사용할 수 있다
    이 포인터는 차례로 데이터를 가리킨다
    구문에는 포인터 선언의 각 간접 참조 수준에 대해 별표(*)가 필요하다
        char a = 'z';
        char* b = &a;
        char** c = &b;
        a       b      c
        'z'    7230   10502
        7230   8092   8092
    선택된 메모리 위치를 7230, 8092및 10502의 각 변수에 대해 임의로 가정하면 다음과 같이 나타낼 수 있다
    이 예에서 새로운 점은 포인터에 대한 포인터인 변수 c이며 세 가자의 다른 간접 참조 수준에서 사용할 수 있으며 각가은 다른 주소 값이다

void Pointer
    void 유형의 포인터는 특별한 유형의 포인터이다
        c++에서 void는 type이 없음을 나타낸다
        따라서 void 포이넡는 유형이 없는 값을 가리키는 포인터이다
    이것은 정수 값이나 부동 소수점에서 문자열에 이르기까지 모든 데이터 유형을 가리킬 수 있으므로 void 포인터에 큰 유연성르 제공한다
    그대로 그들은 큰 한계를 가지고 있다
        그들이 가리키는 데이터는 직접 역 참조될 수 없으며, 
        이러한 이유로 void 포인터의 모든 주소는 구체적인 포인터 유형을 가리키는 다른 포인터 유형으로 변환되어야 한다

% void increase(void* data, int pSize); 함수의 프로토 타입(원형) 
    -> 반드시 다른곳에 정의가 되어 있어야한다

struct of memory 메모리 구조
    프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드되어야 한다
    또한, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요하다
    따라서 컴퓨터의 운영체제(OS)는 프로그램의 실행을 위해 다양한 메모리 공간을 제공하고 있다
    프로그램이 운영체제로부터 할당 받는 대표적인 메모리 공간은 다음과 같다
        프로그램 하나가 아니라 os가 관리하는 메모리
        code 영역                                   낮은 주소
            실행할 프로그램의 코드
            메모리 코드 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부른다
            CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다
        data 영역
            전역 변수 정적 변수
            메모리의 데이터 영역은 프로그램의 전역 변수와 정적 변수(static)가 저장되는 영역이다
                ->정적변수를 외부에서도 쓸수 있는 이유????
            데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다
        heap 영역 (런타임에 크기가 결정됨) -> 개발자에게 가장 중요한 부분
            사용자의 동적 할당
            메모리의 힙 영역은 사용자가 직접 관리할 수 있는 그리고 해야만 하는 메모리 영역이다
            힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다
            힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다
        stack 영역 (컴파일 타임에 크기가 결정됨)     높은 주소
            지역변수 매개변수
            메모리의 스택 영역은 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역이다
            스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다
            이렇게 스택영역에 저장되는 함수의 호출 정보를 스택프레임(stack frame)이라고 한다
            스택 영역은 푸시(push)동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출한다
            이러한 스택은 후입선출(LIFO, Last-In-First-Out)방식에 따라 동작하므로, 가장 늦게 자장된 데이터가 가장 먼저 인출된다
            스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다
                -> 후입선출, 선형자료형, push&pop
            stack frame
                함수가 

C++ Dynamic Allocation 메모리의 동적 할당
    데이터 영여과 스택 영역에 할당하는 메모리의 크기는 컴파일 타임에 미리 결정된다
    하지만 heap 영역의 크기는 프로그램이 실행되는 도중인 런타임에 사용자가 직접 결정하게 된다
    이렇게 런타임에 메모리를 할당 받는 것을 메모리의 동적 할당 이라고 한다
    포인터의 가장 큰 목적은 런 타임에 이름없는 메모리를 할당 받아 포인터에 할당하여, 할당 받은 메모리에 접근하는 것이다
        -> 포인터를 사용하는 가장 큰 목적
    C언어에서는 malloc() 함수 등의 라이브러리 함수를 제공하여 이러한 작업을 수행할 수 있게 해준다
    C++에서도 C언어의 라이브러리 함수를 사용하여 메모리의 동적 할당 및 해제를 할 수 있다
    하지만 C++ 에서는 메모리의 동적 할당 및 해제를 위한 더욱 효과적인 방법을 new연산자와 delete연산자를 통해 제공한다

C malloc() 함수
    #include <stdib.h>
    void* malloc(size_t size);
    malloc 함수는 프로그램이 실행 중일 때 사용자가 직접 힙 영역에 메모리를 할당할 수 있게 해줍니다
    malloc 함수의 원형은 다음과 같습니다.
    <stdlib.h>에 포함된 c standard library이다
    malloc 함수는 인수로 할당 받고자하는 메모리의 크기를 바이트 단위로 전달받는다
    이 함수는 전달받은 메모리 크기에 맞고, 아직 할당되지 않은 적당한 블록을 찾는다 
        -> 사실 os가 찾아주는거임
    이렇게 찾은 블록의 첫 번째 바이트를 가리키는 주소값을 반환한다
    힙 영역에 할당할 수 있는 적당한 블록이 없을 때에는 널 포인터를 반환한다
    주소 값을 반환받기 때문에 힙 영역에 할당된 메모리 공간으로 접근하려면 포인터를 사용해야 한다

C free() 함수
    free 함수는 힙영역에 할당 받은 메모리 공간을 다시 os로 반환해 주는 함수이다
    데이터 영역이나 스택 영역에 할당되는 메모리의 크기는 컴파일 타임에 결정되어, 프로그램이 실행되는 내내 고정된다
    하지만 메모리의 동적 할당으로 힙영역에 생성되는 메모리의 크기는 런 타임 내내 변환된다
    따라서 free 함수를 사용하여 다 사용한 메모리를 해제해주지 않으면, 메모리가 부족해지는 현상이 발생할 수 있다
    이처럼 사용이 끝난 메모리를 해제하지 않아서 메모리가 부족해지는 현상을 메모리 누수라고한다
    함수는 인수로 해제하고자 하는 메모리 공간을 가리키는 포인터를 전달받는다
    인수의 타입이 void 포인터로 선언되어 있으므로, 어떠한 타입의 포인터라도 인수로 전달받을 수 있다

calloc() 함수
    calloc() 함수는 malloc함수와 마찬가지로 힙 영역에 메모리를 동적으로 할당해주는 함수이다
    이 함수와 malloc 함수와 다른 점은 할당하고자 하는 메모리의 크기를 두 개의 인수로 나누어 전달받는 점이다
    또한, calloc함수는 메모리를 할당 받은후에 해당 메모리의 모든 비트 값을 전부 0으로 초기화 해준다
    calloc함수도 free 함수를 통해 할당 받은 메모리를 해제해줘야 한다

realloc() 함수
    realloc 함수는 이미 할당된 메모리의 크기를 바꾸어 재할당할 때에 사용하는 함수이다
    realloc 함수의 첫 번째 인수는 크기를 바꾸고자 하는 메모리 공간을 가리키는 포인터를 전달받는다
    두번째 인수로는 해당 메모리 공간에 재할당할 크기를 전달한다
    따라서 첫 번째 인수로 NULL이 전달되면, malloc함수와 정확히 같은 동작을 한다
        realloc은 쓰레기 값이 들어간다
        realloc은 메모리 공간이 부족하면 임시 공간에 저장한다음에 붙여준다?

C++ new