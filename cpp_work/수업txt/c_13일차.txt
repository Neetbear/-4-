deque 이어서
    양방향
    13일차 이미지는 deque의 구조이다. 일단, 베터와는 다르게 원소들이 메모리에 연속되어 존재하는 것이 아니라 일정 크기로 잘려서 각각의 블록 속에 존재한다
        따라서 이 블록들이 메모리 상에 어느 곳에 위치하여 있는지 저장하기 위해 서 각각의 블록들의 주소를 저장하는 벡터가 필요로 한다
    참고로 이 벡터는 기존의 벡터와는 조금 다르 게, 새로 할당 시에 앞쪽 및 뒤쪽 모두에 공간 을 남겨놓게 된다. (벡터의 경우 뒤쪽에만 공간 이 남았다) 
        따라서 이를 통해 맨 앞과 맨 뒤에 매우 빠른(O(1)) 의 속도로 insert 및 erase 를 수행할 수 있는 것이다

What choose container?
    어떠한 컨테이너를 사용할지는 전적으로 이 컨테이너를 가지고 어떠한 작업들을 많이 하는가에 달려있다
    일반적인 상황에서는 그냥 벡터를 사용한다(거의 만능)
    만약에 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 일을 많이 하고 원소들을 순차적으로만 접근한다면 리스트
    만약에 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이 하면 deque를 사용한다

Associative container
    연관 컨테이너는 시퀀스 컨테이너와는 다르게 키-값 구조를 가진다
        다시 말해 특정한 키를 넣으면 이에 대응되는 값을 돌려준다는 것이다
    물론 템플릿 라이브러리이기 때문에 키와 값 모두 임의의 타입의 객체가 될 수 있다
    연관 컨테이너는 set와 multiset, map, multimap을 지원한다 (보통 set과 map)
        물론 맵과 멀티맵을 셋 처럼 사용할 수 있다
        왜냐하면 해당하는 키가 맵에 존재하지 않으면 당연히 대응되는 값을 가져올 수 없기 때문이다
    하지만 맵의 경우 셋 보다 사용하는 메 모리가 크기 때문에 키의 존재 유무 만 궁금하다면 세트를 사용하는 것이 좋다

set
    set에 원소를 추가하기 위해서는 시퀀스 컨테이너처럼 insert 함수를 사용하면 된다
        한 가지 다른 점은 시퀀스 컨테이너처럼 어디에 추가할지에 대한 정보가 없다는 점이다
    시퀀스 컨테이너가 상자 하나에 원소를 한 개 씩 담고, 각 상자에 번호를 매긴것이라면,
        세트는 그냥 큰 상자 안에 모든 원소들을 쑤셔 넣은 것이라 보면 된다
        그 상장 안에 원소가 어디에 있는지는 중요 한 것이 아니고, 
        그 상자 안에 원소가 ' 있냐/없냐' 만이 중요한 정보이다

    set은 원소를 넣은 순서에 상관없이 정렬된 상태를 유지하며 추가한다
        -> 내부적으로 트리 구조로 구성되어 있기 때문이다? binary search?
    그림은 흔히 볼 수 있는 트리 구조를 나타낸다. 
    각각 의 원소들은 트리의 각 노드들에 저장되어 있고, 다음과 같은 규칙을 지키고 있다.
        왼쪽에 오는 모든 노드들은 나보다 작다
        오른쪽에 있는 모든 노드들은 나보다 크다
    세트의 중요한 특징으로 바로 세트안에는 중복된 원소들이 없다는 점이다

%클래스 객체를 세트에 넣고 싶을때
    operator<를 재정의 해줘야 한다 ( 트리구조 -> 세트 내부적으로 정렬 시에 상수 반복자르 사용하기 때문이다 )
        -> 상수 반복자는 상 수 함수만을 호출할 수 있다
    return jobDesc < t.jobDesc;
    사전상 먼저 오는 것이 먼저 나오게 된다
%operator< 말고 다른 방법 operator()

map
    맵은 셋과 거의 똑같은 자료 구조이다
    다만 세트의 경우 키만 보관했지만, 맵의 경우 키에 대응되는 값까지도 같이 보관하게 된다
    단, 키값은 숫자를 권장한다

    맵의 경우 템플릿 인자로 2 개를 가 지는데, 첫번째는 키의 타입이고, 두 번째는 값의 타입입니다
    맵에 원소를 넣기 위해서는 반드시 std::pair 객체를 전달해야 합니다

    맵의 경우 operator[]를 이용해서 해당하는 키가 맵에 없다면 새로운 원소를 추가할 수 도 있다
    만일 키가 이미 존재한다면 값 이 대체될 것이다

    맵의 경우도 세트와 마찬가지로 반복자를 이용해서 순차적으로 맵에 저장되어 있는 원소들을 탐색할 수 있다
        세트의 경우 *itr가 저장된 원소를 바로 카리켰는데, 맵의 경우 반복자가 맵에 저장되어 있는 std::pair 객체를 가리키게 된다
    따라서 itr->first를 하면 해당 원소의 키를, itr->second를 하면 해당 원소의 값을 알 수 있다
    
    double의 디폴트 생성자의 경우 그냥 변수를 0으로 초기화 해버린다
    따라서 되도록이면 find 함수로 원 소의 키가 존재하는지 먼저 확인 후 에, 값을 참조하는 것이 좋다

    find 함수는 맵에서 해당하는 키를 찾아서 이를 가리키는 반복자를 반환한다
        만약에, 키가 존재하지 않는다면 end()를 반환한다
    주의할 점은 맵 역시 세트 처럼 중복된 원소를 허락하지 않는다는 점이다. 
        이미, 같은 키가 원소로 들어 있다면 나중에 오는 insert 는 무시된다
    만약에, 원소에 대응되는 값을 바꾸고 싶다면 insert 를 하지 말고, [] 연산자로 대응되는 값을 바꿔주면 된다

멀티세트와 멀티맵
    세트와 맵 모두 중복된 원소를 허락하지 않는다
        만일, 이미 원소가 존재하고 있는데 insert를 하였으면 무시가 되었다
    하지만 멀티 세트와 멀트 맵은 중복된 원소를 허락한다

    맵과는 다르게, 한 개의 키에 여러개의 값이 대응 될 수 있다는 것은 알 수 있다
    하지만 이 때문에 [] 연산자를 멀티맵의 경우 사용할 수 없다
    m[1] 같이 접근한다면 어떤 값에 접근 할지 모르기 때문에 멀티맵의 경우 아예 [] 연산자를 제공하지 않는다

find 함수를 사용했을 때 무엇을 리턴할까?
    일단 해당하는 키가 없으면 m.end() 를 리턴한다
    사실 C++ 표준을 읽어보면 무엇을 반환하라고 정해 놓지 않았다
    즉, 해당되는 값들 중 아무거나 반환해도 상관 없다는 뜻이다
    그렇다면 1 에 대응되는 값들이 뭐가 있는지 어떻게 알까? 
    이를 위해 멀티맵은 다음과 같은 함수 equal_range를 제공하고 있다
    equal_range 함수의 경우 인자로 멀티맵의 키 를 받은 뒤에, 
        이 키에 대응되는 원소들의 반복 자들 중에서 시작과 끝 바로 다음을 가리키는 반복자를 std::pair 객체로 만들어서 반환한다
    즉, begin() 과 end() 를 std::pair 로 만들어서 세트로 리턴 한다. 다만, first 로 시작점을, second 로 끝점 바로 뒤를 알 수 있다. 
        왜 끝점 바로 뒤를 가리키는 반복자를 리턴 하는지는 굳이 설명 안 해도 알 수 있다
    대응되는 모든 원소들을 볼 수 있게 된다

Algorithm
    C++ 표준 라이브러리는 앞에서 이야기 했던 대로, 
        컨테이너에 반복자들을 가지고 이런 저런 작업을 쉽게 수행할 수 있도록 도와주는 라이브러리이다
    여기서 말하는 이런 저런 작업이란, 정렬이나 검색과 같이 단순한 작업들 말고도,
        '이런 조건이 만족하면 컨테이너에서 지워줘'나 ' 이린 조건이 만족하면 1을 더해'와 같은 복잡한 명령의 작업들도
        알고리즘 라이브러리 를 통해 수행할 수 있다
    알고리즘에 정의되어 있는 여러가지 함수들로 작업을 수행하게 된다

정렬(sort, table_sort, partial_sort)
    알고리즘 라이브러리에서 지원하는 정렬은 3종류이다
        sort : 일반적인 정렬 함수
        stable_sort : 정렬을 하되 원소들 간의 순서를 보존한다
                    컨테이너 상 에서 [a,b] 순으로 있었다면 정렬 시에도 (크기가 같다면) [a,b] 순으로 나오게 된다
                    이 때문 에 sort 보다 좀 더 느리다
        partial_sort : 배열의 일부분만 정렬한다

sort 
    sort 함수는 정렬할 원소의 시작 위치와, 마지막 위치 바로 뒤를 반복자로 받는다
    참고로 sort에 들어가는 반복자의 경우 반드시 임의접근 반복자 타입을 만족해야하므로, 
        우리가 봐왔던 컨테이너들 중에선 벡터와 deque만 가능하고 나머지 컨 테이너는 sort 함수를 적용할 수 없다
        예를 들어 리스트의 경우 반복자 타입이 양 방향 반복자(BidirectionalIterator) 이므로 안된다
    sort 함수는 기본적으로 오름차순으로 정렬을 해준다
만약에 내림 차순으로 정렬하고 싶다면?
    대부분의 알고리즘은 3 번째 인자로 특 정한 조건을 전달한다고 하였는데, 
    여기에 우리가 비 교를 어떻게 수행할 것인지에 대해 알려주면 된다

partial_sort
    partial_sort 함수는 일부만 정렬하는 함수라고 하였다
    start, middle, end 3개의 인자를 기본으로 받는다
    이때 정렬을 start부터 end까지 중에서 start부터 middle까지의 원소들만 제일 작은 순으로 정렬시킨다? 
    // 1등부터 end등까지 마구자비로 있을때 1등부터 middle등까지만 오름차순으로 정렬하고 나머지는 그대로 나오는 느낌

stable sort
    stable sort는 원소가 삽입되어 있는 순 서를 보존하는 정렬 방식이라고 하였다
        stable_sort 가 확실히 어떻게 sort 와 다른지 보여주기 위해서 다음과 같은 클래스를 만들어보자
    User 클래스는 name 과 age 를 멤 버로 갖는데, 크기 비교는 이름과 관계 없이 모두 age 로 하게 된다. 
        즉 age 가 같다면 크기가 같다고 볼 수 있다
    
    처음에 벡터에 원소들을 삽입하는 부분인데, 이름은 aa, ab,ac,... 순으로 하되 age의 경우 0부터 10사이의 랜덥 값을 부여하였다
        즉 name의 경우 string 순서대로 되어있고, age의 경우 랜덤 순서로 되어 있다
    stable_sort 는 삽입되어 있던 원소들 간 의 순서를 보존 한다고 했다. 
        따라서 같 은 age 라면 반드시 삽입된 순서, 즉 name 순으로 나올 것이다
        -> 왜냐하면 애초에 name 순으로 넣었기 때문이다

lambda function
    람다 함수는 c++에서는 C++11에서 처음으로 도입되었다
        람다 함수를 통해 쉽게 이름이 없는 함수 객체를 만들 수 있게 되었다
    익명함수 객체를 말한다

람다 함수의 정의
    [](int i) -> bool { return i % 2 == 1; }
    함수 정의를 보자면 인자로 int i 를 받고, bool 을 반환하는 람다 함 수를 정의한 것이다
    반환 타입을 생략 한다면 컴파일러가 알아서 함수 본체에 서 return 문을 보고 리턴 타입을 추측 해준다
    [capture list] (받은 인자) -> 리턴타입 {함수 본체}

리턴 타입 생략할 경우
    [capture list] (받은 인자) {함수 본체}

    람다 함수도 말 그대로 함수이기 때문에 자기 자신만의 영역을 가진다
        따라서 일반적인 상황이라면 함수 외부에서 정의된 변수들을 사용할 수 없다
    예를 들어서 최대 2개 원소만 지우고 싶은 경우 예제와 같이 람다 함수 외부에 몇 개를 
        지웠는지 변수를 정의한 뒤에 사용해야만 하는데 함수 안에서 정의하면 함수
        호출될 때마다 새로 생성된다
    문제는 그 변수에 접근할 수 없다는 점이다
        하지만 놀랍게도 람다 함수의 경우 그 변수에 접근할 수 있다
        바로 캡쳐 목록을 사용하는 것이다

    예제와 같이 캡쳐 목록에는 어떤 변수를 캡쳐할 지 써주면 된다
        위 경우 num_erased를 캡쳐하였다
        즉 람다 함수 내에서 num_erased를 마치 같은 scope 안에 있는 것처럼 사용할 수 있게된다
    num_erased 앞에 & 가 붙어있는데 이 는 실제 num_erased 의 레퍼런스를 캡 쳐 한다는 의미이다. 
        즉 함수 내부에서 num_erased 의 값을 바꿀 수 있게 될수 있게 된다

    &를 붙이지 않는다면 복사본을 얻게 되는데, 그 복사본의 형태는 const이다
        따라서 예제 처럼 함수 내부에서 num_erased 의 값을 바꿀 수 없게 된다 
        그렇다면 클래스의 멤버 함수 안 에서 람다를 사용할 때 멤버 변수들 을 참조하려면 어떻게 해야할까?
    쉽게 생각해보면 그냥 똑같이 num_erased 를 & 로 캡쳐 해서 람다 함수 안에서 사용할 수 있을 것 같지만 실제로는 컴파일 되지 않는다
    왜냐하면 num_erased 가 일반 변수가 아니라 객체에 종속되어 있는 멤버 변 수 이기 때문이다
        즉 람다 함수는 num_erased 를 캡쳐하려고하면 이 num_erased 가 이 객체의 멤버 변수가 아니라 그냥 일반 변수라고 생각 하게 된다
    이것을 해결하기 위해선 직접 멤버 변수를 전달하기 보다는 this 를 전달해주면 된다
    this 를 복사본으로 전달해서 (참고로 this 는 레퍼런스로 전달할 수 없다) 함수 안에서 this 를 이용해서 멤버 변수들을 참조해서 사용하면 된다
    예제에 설명한 경우 말고도 캡쳐 리스트의 사용 방법 은 꽤나 많은데 아래 간단히 정리해보도록 하겠다
        [] 아무것도 캡쳐 안함
        [&a, b] a는 래퍼런스로 b는 const로 
        [&] 외부의 모든 변수를 래퍼런스로
        [=] 외부의 모든 변수를 const(복사본)으로