deque 이어서
    양방향
    13일차 이미지는 deque의 구조이다. 일단, 베터와는 다르게 원소들이 메모리에 연속되어 존재하는 것이 아니라 일정 크기로 잘려서 각각의 블록 속에 존재한다
    따라서 이 블록들이 메모리 상에 어느 곳에 위치하여 있는지 

What choose container?
    어떠한 컨테이너를 사용할지는 전적으로 이 컨테이너를 가지고 어떠한 작업들을 많이 하는가에 달려있다
    일반적인 상황에서는 그냥 벡터를 사용한다(거의 만능)
    만약에 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 일을 많이 하고 원소들을 순차적으로만 접근한다면 리스트
    만약에 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이 하면 deque를 사용한다

Associative container
    연관 컨테이너는 시퀀스 컨테이너와는 다르게 키-값 구조를 가진다
        다시 말해 특정한 키를 넣으면 이에 대응되는 값을 돌려준다는 것이다
    물론 템플릿 라이브러리이기 때문에 키와 값 모두 임의의 타입의 객체가 될 수 있다
    연관 컨테이너는 set와 multiset, map, multimap을 지원한다 (보통 set과 map)
        물론 맵과 멀티맵을 셋 처럼 사용할 수 있다
        왜냐하면 해당하는 키가 맵에 존재하지 않으면 당연히 대응되는 값을 가져올 수 없기 때문이다
    하지만 맵의 경우 

set
    set에 원소를 추가하기 위해서는 시퀀스 컨테이너처럼 insert 함수를 사용하면 된다
        한 가지 다른 점은 시퀀스 컨테이너처럼 어디에 추가할지에 대한 정보가 없다는 점이다
    시퀀스 컨테이너가 상자 하나에 원소를 한 개 씩 담고, 각 상자에 번호를 매긴것이라면,
        세트는 그냥 큰 상자 안에 모든 원소들을 쑤셔 넣은 것이라 보면 된다
        그 상장 안에 원소가 어디에 있냐가 
    set은 원소를 넣은 순서에 상관없이 정렬된 상태를 유지하며 추가한다
        -> 내부적으로 트리 구조로 구성되어 있기 때문이다? binary search?
    세트의 중요한 특징으로 바로 세트안에는 중복된 원소들이 없다는 점이다

%클래스 객체를 세트에 넣고 싶을 때
    operator<를 재정의 해줘야 한다 ( 트리구조 -> 세트 내부적으로 정렬 시에 상수 반복자르 사용하기 때문이다 )
    
    return jobDesc < t.jobDesc;
    사전상 먼저 오는 것이 먼저 나오게 된다

%operator< 말고 다른 방법 operator()

map
    맵은 셋과 거의 똑같은 자료 구조이다
    다만 세트의 경우 키만 보관했지만, 맵의 경우 키에 대응되는 값까지도 같이 보관하게 된다
    단, 키값은 숫자를 권장한다

    맵의 경우 operator[]를 이용해서 해당하는 
    만일 키가 이미 존재한다면 

    맵의 경우도 세트와 마찬가지로 반복자를 이용해서 순차적으로 맵에 저장되어 있는 원소들을 탐색할 수 있다
        세트의 경우 *itr가 저장된 원소를 바로 카리켰는데, 맵의 경우 반복자가 맵에 저장되어 있는 std::pair 객체를 가리키게 된다
    따라서 itr->first를 하면 해당 원소의 키를, itr->second를 하면 해당 원소의 값을 알 수 있다
    
    double의 디폴트 생성자의 경우 그냥 변수를 0으로 초기화 해버린다

    findt 함수는 맵에서 해당하는 키를 찾아서 이를 가리키는 반복자를 반환한다
    만약에, 키가 존재하지 않는다면 end()를 반환한다

멀티세트와 멀티맵
    세트와 맵 모두 중복된 원소를 허락하지 않는다
        만일, 이미 원소가 존재하고 있는데 insert를 하였으면 무시가 되었다
    하지만 멀티 세트와 멀트 맵은 

    맵과는 다르게, 한 개의 키에 여러개의 값이 대응 될 수 있다는 것은

    사실 C++ 표준을 읽어보면 무엇을 반환하라고 정해 놓지 않았다
    즉, 해당되는 값들 중 아무거나 반환해도 상관 없다는 뜻이다

Algorithm
    C++ 표준 라이브러리는 앞에서 이야기 했던 대로, 
        컨테이너에 반복자들을 가지고 이런 저런 작업을 쉽게 수행할 수 있도록 도와주는 라이브러리이다
    여기서 말하는 이런 저런 작업이란, 정렬이나 검색과 같이 단순한 작업들 말고도,
        '이런 조건이 만족하면 컨테이너에서 지워줘'나 ' 이린 조건이 만족하면 1을 더해'와 같은 복잡한 명령의 작업들도

정렬(sort, table_sort, partial_sort)
    알고리즘 라이브러리에서 지원하는 정렬은 3종류

sort 
    sort 함수는 정렬할 원소의 시작 위치와, 마지막 위치 바로 뒤를 반복자로 받는다
    참고로 sort에 들어가는 반복자의 경우 반드시 임의접근 반복자 타입을 만족해야하므로, 
        우리가 봐왔던 컨테이너들 중에선 벡터와 deque
    
    sort 함수는 기본적으로 오름차순으로 정렬을 해준다

partial_sort
    partial_sort 함수는 일부만 정렬하는 함수라고 하였다
    start, middle, end 3개의 인자를 기본으로 받는다
    이때 정렬을 start부터 end까지 중에서 start부터 middle까지의 원소들만 제일 작은 순으로 정렬시킨다? 
    // 1등부터 end등까지 마구자비로 있을때 1등부터 middle등까지만 오름차순으로 정렬하고 나머지는 그대로 나오는 느낌

stable sort
    stable sort는 원소가 삽입되는 
    
    처음에 벡터에 원소들을 삽입하는 부분인데, 이름은 aa, ab,ac,... 순으로 하되 age의 경우 0부터 10사이의 랜덥 값을 부여하였다
        즉 name의 경우 string 순서대로 되어있고, age의 경우 랜덤 순서로 되어 있다

lambda function
    람다 함수는 c++에서는 C++11에서 처음으로 도입되었다
        람다 함수를 통해 쉽게 이름이 없는 함수 객체를 만들 수 있게 되었다
    익명함수 객체를 말한다

람다 함수의 정의
    [](int i) -> bool { return i % 2 == 1; }
    [capture list] (받은 인자) -> 리턴타입 {함수 본체}

리턴 타입 생략할 경우
    [capture list] (받은 인자) {함수 본체}

    람다 함수도 말 그대로 함수이기 때문에 자기 자신만의 영역을 가진다
        따라서 일반적인 상황이라면 함수 외부에서 정의된 변수들을 사용할 수 없다
    예를 들어서 최대 2개 원소만 지우고 싶은 경우 예제와 같이 람다 함수 외부에 몇 개를 
        지웠는지 변수를 정의한 뒤에 사용해야만 하는데 함수 안에서 정의하면 함수
        호출될 때마다 새로 생성된다
    문제는 그 변수에 접근할 수 없다는 점이다
        하지만 놀랍게도 람다 함수의 경우 그 변수에 접근할 수 있다
        바로 캡쳐 목록을 사용하는 것이다

    예제와 같이 캡쳐 목록에는 어떤 변수를 캡쳐할 지 써주면 된다
        위 경우 num_erased를 캡쳐하였다
        즉 람다 함수 내에서 num_erased를 마치 같은 scope 안에 있는 것처럼 사용할 수 있게된다
    
    &를 붙이지 않는다면 복사본을 얻게 되는데, 그 복사본의 형태는 const이다
    
    [] 아무것도 캡쳐 안함
    [&a, b] a는 래퍼런스로 b는 const로 
    [&] 외부의 모든 변수를 래퍼런스로
    [=] 외부의 모든 변수를 const(복사본)으로