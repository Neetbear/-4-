C++ Namespaces
    C++에서는 변수, 함수, 구조체, 클래스 등을 서로 구분하기 위해서 이름으로 사용되는 다양한 내부
        식별자를 가지고 있다
    하지만 프로그램이 복잡해지고 여러 라이브러리가 포함될수록 내부 식별자간에 충돌할 가능성도 그만큼 커진다
        외부라이브러리 사용시 현재 모듈과 같은 함수가 존재 한다면 함수 이름의 충돌이 발생해 링크가 되지 않는다
    이러한 이름 충돌 문제를 C++에서는 네임스페이스를 통해 해결하고 있다
    C++에서 네임스페이스란 내부 식별자에 사용될 수 있는 유효 범위를 제공하는 선언적 영역을 의미한다

Defining a Namespaces
    c++ 에서는 네임스페이스 키워드를 사용하여 사용자가 새로운 네임스페이스를 정의할 수 있다
    이러한 네임스페이스는 전역 위치 뿐만 아니라 다른 네임스페이스 내에서도 정의될 수 있다
    하지만 code 블록 내에서는 정의될 수 없으며, 기본적으로 외부 연결을 가지게 된다
    일반적으로 Namespaces는 헤더 파일에서 정의되며, 언제나 새로운 이름을 추가할 수 있도록 개방되어 있다
    c++에서는 전역 네임스페이스라고 하는 파일 수준의 선언 영역이 존재한다
    일반적으로 식별자의 네임스페이스가 명시되지 않으면, 전역 네임스페이스에 자동으로 포함된다

Accessing a Namespaces
    네임스페이스를 정의한 수에는 해당 네임스페이스로 접근할 수 있는 방법이 필요하다
    네임스페이스에 접근하기 위해서는 범위지정연산(::)를 사용하여, 해당 이름을 특정 네임스페이스로 제한하면 된다

access to simplified Namespaces
    네임스페이스에 속한 이름을 사용할 때마다 매번 범위 지정연산자를 사용하여 이름을 제한하는 것을 매우 불편하다
    또한, 길어진 코드로 인해 가독성 또한 떨어지게된다
    C++에서는 이러한 불편함을 해소 할수 있도록 다음과 같은 방법을 제공하고 있다

    using 지시자
        using 지시자는 명시한 네임스페이스에 속한 이름을 모두 가져와 범위 지정 연산자를 사용하지 않고도 사용할 수 있게 해준다
        전역 범위에서 사용된 using 지시자는 해당 네임스페이스의 모든 이름을 전역적으로 사용할 수 있게 만들어 준다
        또한, 블록 내에서 사용된 using 지시자는 해당 블록에서만 해당 네임스페이스의 모든 이름을 사용할 수 있게 해준다

    using 선언
        using 지시자가 명시한 네임스페이스의 모든 이름을 사용할 수 있게 해줬는데 

    불연속 네임스페이스(Discontinguous Namespaces)
        네임스페이스는 여러 부분으로 정의될 수 있으므로 네임스페이스는 별도로 정의될 수 있으므로 네임스페스는 별도로 정의된 부분의 합으로 구성된다
            네임스페이스의 개별 부분은 여러 파일에 분산될 수 있다
        따라서 네임스페이스의 한 부분에 다른 파일에 정의된 이름이 필요한 경우 해당 이름을 계속 선언해야한다
        다음 네임스페이스
    
    중첩된 네임스페이스(nested Namespaces)
        네임스페이스는 다음과 같이 다른 네임스페이스 안에 하나의 네임스페이스를 정의할 수 있는 중첩사용도 가능하다
        다음과 같이 확인 연산자를 사용하여 중첩된 네임스페이스의 멤버에 엑세스 할 수 있다

C++ data structure(구조체)
    C/C++ 배열을 사용하면 같은 종류의 여러 데이터 항목을 결합하는 변수를 정의할 수 있지만 구조체는 다른 종류의 데이터 항목을 결합할 수 있는
        또 다른 사용자 정의 데이터 타입(유형)이다
    배열이 같은 타입의 변수 집합이라고 한다면, 구조체는 다양한 타입의 변수 집합을 하나의 타입으로 나타낸 것이다
    이때 구조체를 구성하는 변수를 구조체의 멤버 또는 멤버 변수라고 한다
    c/c++의 구조체는 변수뿐만 아니라 함수까지도 멤버로 가질 수 있다
    또한, c/c++의 구조체는 타입일 뿐만 아니라, 객체 지향 프로그래밍의 핵심이 되는 클래스의 기초가 되었다

    Defining a structure
        구조체를 정의하려면 struct문을 사용한다
        struct문은 프로그램에 대해 둘 이상의 멤버가 있는 새 데이터 유형을 정의한다
    
    Accessing structure members
        구조체의 모든 멤버에 엑세스하려면 멤버 액세스 연산자(.)를 사용한다
        멤버 액세스 연산자를 
    
    structure as function arguments
        다른 변수나 포인터를 전달할 때와 매우 유사한 방식으로 구조체를 함수의 아규먼트로 전달할 수 있다

    the typedef keyword
        구조체를 정의하는 더 쉬운 방법이 있거나 생성한 유형을 alias(별칭, tag)로 지정할 수 있다
    
    size of structure
        구조체의 크기는 멤버 변수들의 크기에 따라 결정된다
        하지만 구조체의 크기가 언제나 멤버 변수들의 크기 총합과 일치하는 것은 아니다

        위의 예제에서 구조체 멤버 변수의 크기는 각각 1,4,8 바이트이나 구조체의 크기는 총합인 13이 아닌 16바이트가 된다
        구조체를 메모리에 할당할 때 컴파일러는 프로그램의 속도 향상을 위해 바이트 패딩이라는 규칙을 이용한다
        구조체를 다양한 크기의 타입을 멤버 변수로 가질 수 있는 타입이다
        하지만 컴파일러는 메모리의 접근을 쉽게 하려고 

        예제에서는 크기가 가장 큰 double형 타입의 크기인 8바이트가 기준이 된다
        맨 처음 char형 멤버 변수를 위해 8바이트가 할당되며,할당되는 1바이트를 제외한 7바이트가 남게 된다
        그 다음 int형 멤버 변수는 남은 7바이트보다 작으므로, 그대로 7바이트 중 4바이트를 할당하고 3바이트가 남게 된다
        마지막 double형 멤버 변수는 8바이트인데 남은 공간은 3바이트 뿐이므로 다시 8바이트를 할당 받는다
        따라서 이 구조체의 크기는 총 16바이트가 되며, 

        구조체 안에 변수를 선언할 때 크기가 가장 작은 자료형 -> 크기가 큰 자료형 순으로 선언한다
            위의 예시에서 살펴 봤듯이, 구조체는 변수를 선언하는 순서가 중요하다
            따라서 크기가 작은 자료형부터 크기가 큰 자료형 순으로 구조체를 선언했다면 패딩으로 인한 문제가 줄어든다
        메모리 절약을 생각한다면, 맨 처음 #pragma pack(push, 1) 

    C++ what is oop(object oriented programming)?
        oop는 객체 지향 프로그래밍의 약자이다
        절차적 프로그래밍은 data에 대한 작업을 수행하는 절차 혹은 함수를 작성하는 것이고 객체 지향 프로그래밍은 데이터와 함수를 모두 포함하는 객체를 만드는 것이다
        객체 지향 프로그래밍은 절차적프로그래밍에 비해 몇가지 장점이 있다
            oop는 더 빠르고 쉽게 실행할 수 있다
            oop는 프로그램에 대한 명확한 구조를 제공한다
            oop는 C++ 코드 DRY(don't repeat yourself)를 유지하는데 도움이 되며 코드를 유지 관리 , 수정 및 디버그하기 쉽게 만든다
            oop를 사용하면 더 작은 코드와 더 짧은 개발 시간으로 완전히 재사용 가능한 application을 만들 수 있다
        %dry(don't repeat yourself) 원칙은 코드 반복을 줄이는 것이다
            애플리케이션에 공통적인 코드를 추출하여 한 곳에 배치하고 반복하지 않고 재사용해야 한다

    C++ what are classes and objects?
        class와 object는 객체 지향 프로그래밍의 두 가지 주요 측면이다
        클래스와 객체의 차이점을 보려면 다음 그림을 참고 한다
        class는 object의 템플릿(틀)이고 object는 class의 instance이다
            개별 객체가 생성되면 클래스에서 모든 변수와 기능을 상속한다
    
    C++ classes and objects
        c++는 object oriented programming 언어이다
        C++의 모든 것은 속성 및 메서드와 함께 class 및 object와 연관되어 있다
        예를 들어 실생활에서 자동차는 물건이다
            자동차는 무게와 색상과 같은 속성과 
            drive, brake와 같은 방법(매서드)를 가지고 있습니다
        attribute와 method는 기본적으로 class에 속하는 변수와 함수이다 
            이들은 class member 라고 한다
        class는 우리 프로그램에서 사용할 수 있는 사용자 정의 데이터 유형이며 object constructor를 통하여 작동한다

    C++ class definitions
        클래스를 정의할 때 데이터 유형에 대한 청사진을 정의한다
            이것은 실제로 데이터를 정의하지 않지만 클래스 이름이 의미하는 바, 즉 클래스의 객체가
            구성되는 것과 그러한 객체에서 수행할 수 있는 작업을 정의한다
        클래스 정의는 class 키워드로 시작하고 그 뒤에 클래스 이름이 온다
            한쌍의 중괄호로 묶인 클래스 본문 클래스 정의 뒤에

        class 키워드는 myclass라는 클래스를 만드는데 사용된다
        public 키워드는 클래스의 멤버가 클래스 외부에서 엑세스 할 수 있도록 지정하는 액세스 지정자이다
        클래스 내부에는 int 변수 myNum과 string변수 myString이 있다 
            변수가 클래스 내에서 선언되면 속성이라고 한다
            마지막으로 클래스 정의를 세미콜론으로 끝낸다
        
    define c++ object
        클래스는 객체에 대한 청사진을 제공하므로 기본적으로 객체는 클래스에서 생성된다
        기본 유형의 변수를 선언하는 것과 정확히 같은 종류의 선언으로 클래스의 객체를 선언한다
    
    Multiple object

    class methods
        method는 class에 속하는 function이다
        클래스에 속하는 함수를 정의하는 두 가지 방법이 있다
            inside class definition
            outside class definition
                클래스 정의 외부에서 함수를 정의하려면 클래스 내부에서 선언한 다음 클래스 외부에서 정의해야 합니다
                이것은 클래스 이름, scope resolution(::)
        
